#include"AFE.h"

void Encode1(SendPacket *SPacket, BYTE b){
	SPacket->Packet[SPacket->Size] = b;
	SPacket->Size++;
}

void Encode2(SendPacket *SPacket, WORD w){
	*(WORD *)&SPacket->Packet[SPacket->Size] = w;
	SPacket->Size += 2;
}

void Encode4(SendPacket *SPacket, DWORD dw){
	*(DWORD *)&SPacket->Packet[SPacket->Size] = dw;
	SPacket->Size += 4;
}

void EncodeString(SendPacket *SPacket, char *String){
	int i;
	for(i=0; String[i]; i++){
	}
	Encode2(SPacket, i);
	RtlCopyMemory(&SPacket->Packet[SPacket->Size], String, i);
	SPacket->Size += i;
}

BYTE Decode1(RecvPacket *RPacket){
	BYTE b = RPacket->Packet[RPacket->ReadBuffer];
	RPacket->ReadBuffer++;
	return b;
}

WORD Decode2(RecvPacket *RPacket){
	DWORD w = *(WORD *)&RPacket->Packet[RPacket->ReadBuffer];
	RPacket->ReadBuffer += 2;
	return w;
}

DWORD Decode4(RecvPacket *RPacket){
	DWORD dw = *(DWORD *)&RPacket->Packet[RPacket->ReadBuffer];
	RPacket->ReadBuffer += 4;
	return dw;
}

char* DecodeString(RecvPacket *RPacket){
	char *Buffer;
	int i, BufferSize = Decode2(RPacket);

	Buffer = (char *)malloc(BufferSize + 1);

	for(i=0; i<BufferSize; i++){
		Buffer[i] = RPacket->Packet[RPacket->ReadBuffer++];
	}
	Buffer[i] = 0;
	return Buffer;
}

DWORD _SendFunction = 0x00498600;

void SendFunction(SendPacket *SPacket){
	_asm{
		push [SPacket]
		call dword ptr [_SendFunction]
		add esp,0x04
	}
}

DWORD RequestID;

DWORD CharID = 0x0048609D;

void RequestHook(RecvPacket *RPacket){
	char *Buffer;
	SendPacket SPacket;
	ZeroMemory(&SPacket, sizeof(SendPacket));
	BYTE Type = Decode1(RPacket);
	SPacket.Packet  = (BYTE *)malloc(256);
	ZeroMemory(SPacket.Packet, 256);

	switch(Type){
	case 0x14://Invite
		if(dwCase == 1){
			Encode2(&SPacket, 0x0132);
			Encode1(&SPacket, 0x15);
			Encode4(&SPacket, CharID);
			SendFunction(&SPacket);
		}
		break;
	case 0x15://Invited
		if(dwCase == -1){
			Decode1(RPacket);
			Buffer = DecodeString(RPacket);
			//SetCharacterName(Buffer);
			RequestID = Decode4(RPacket);
			Encode2(&SPacket, 0x0132);
			Encode1(&SPacket, 0x13);
			Encode4(&SPacket, RequestID);
			Encode1(&SPacket, 0x00);
			Encode1(&SPacket, 0x00);
			SendFunction(&SPacket);
		}
		break;
	case 0x70://Ended
		Encode2(&SPacket, 0x0132);
		Encode1(&SPacket, 0x1C);
		SendFunction(&SPacket);
		break;
	case 0x1C://ReTry
		if(dwCase == 1){
			Encode2(&SPacket, 0x0132);
			Encode1(&SPacket, 0x10);
			Encode1(&SPacket, 0x03);
			Encode1(&SPacket, 0x00);
			SendFunction(&SPacket);
		}
		break;
	default:
		break;
	}

	free(SPacket.Packet);
}

void _stdcall ResponseHook(RecvPacket *RPacket){
	SendPacket SPacket;
	ZeroMemory(&SPacket, sizeof(SendPacket));
	RPacket->ReadBuffer = 6;
	Decode4(RPacket);
	BYTE Type = Decode1(RPacket);
	SPacket.Packet  = (BYTE *)malloc(256);
	ZeroMemory(SPacket.Packet, 256);

	switch(Type){
	case 0x03:
		if(dwCase == 1){//Winner
			Encode2(&SPacket, 0x0132);
			Encode1(&SPacket, 0x61);
			Encode1(&SPacket, 0x01);
			SendFunction(&SPacket);
		}
		else if(dwCase == -1){//Loser
			Encode2(&SPacket, 0x0132);
			Encode1(&SPacket, 0x61);
			Encode1(&SPacket, 0x00);
			SendFunction(&SPacket);
		}
		break;
	default:
		break;
	}

	free(SPacket.Packet);
}

AirMemory AM;
void WriteHook(){
	AM.Init();
	AM.WriteHook(0x0074EDA4, CALL, RequestHook);
	AM.WriteHook(0x0145BF76, CALL, ResponseHook);
}